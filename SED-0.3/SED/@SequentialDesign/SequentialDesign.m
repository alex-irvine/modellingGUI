%> @brief The main class for the Sequential Design Toolbox.
%> This class will provide an interface to sequentially generate points for
%> a given problem, using a given sequential design technique, as defined by
%> xml files.
classdef SequentialDesign
	
	properties
		logger;
		generator;
		initialDesign;
		samples;
		values;
		config;
		inputMinima;
		inputMaxima;
		stepSize;
		requireOutputs;
		nOutputsAdded;
		plotLive;
	end
	
	methods
		
		%> @brief Sequential design constructor.
		%> @param problemFile The xml file or struct containing the information about the problem.
		%> @param methodFile The xml file containing the configuration for the sequential design algorithm. Defaults to mc-intersite-projected-threshold.xml if not provided.
		function this = SequentialDesign(problem, methodFile)
			
			% no method defined - go to default
			if ~exist('methodFile', 'var')
				methodFile = 'methods/mc-intersite-projected-threshold.xml';
			end
			
			% logget
			logger = Logger.getLogger('SequentialDesign');
			this.logger = logger;
			
			% first create the object from the files
			this = this.makeConfig(problem, methodFile);
			
			% store the initial design
			this.samples = this.initialDesign;
				
			% create an initial state
			this.values = zeros(size(this.samples,1), this.config.output.getOutputDimension());
			
			% step size is 1 by default
			this.stepSize = 1;
			
			% number of outputs added
			this.nOutputsAdded = 0;
			
			% don't plot live
			this.plotLive = false;
			
			% print some info
			logger.info(sprintf('Input dimension: %dD', this.config.input.getInputDimension()));
			if this.config.output.getOutputDimension() > 0
				logger.info(sprintf('Output dimension: %dD', this.config.output.getOutputDimension()));
			end
			logger.info(sprintf('Sequential design method: %s', methodFile));
			logger.info(sprintf('Points generated by initial design: %d points', size(this.samples,1)));
			logger.info('Ready for use: call generatePoints to generate new design points');
		end
		
		%> @brief Get the initial design.
		function design = getInitialDesign(this)
			design = this.transformToSimulatorSpace(this.initialDesign);
		end
		
		%> @brief Get all the points generated thus far.
		function [points, values] = getAllPoints(this)
			points = this.transformToSimulatorSpace(this.samples);
			values = this.values;
		end
		
		%> @brief Get all points generated thus far, excluding the initial design.
		function [points, values] = getAllPointsWithoutInitialDesign(this)
			points = this.transformToSimulatorSpace(this.samples);
			values = this.values;
			nInitialSize = size(this.initialDesign,1);
			points = points((nInitialSize+1):end,:);
			values = values((nInitialSize+1):end,:);
		end
		
		%> @brief Get metrics abount the design that was generated. Can be used for comparison.
		%> The return parameter is optional. Can also calculate the same
		%> metrics for any design provided by the user as the optional
		%> parameter.
		function [metrics] = getMetrics(this, points)
			if ~exist('points', 'var')
				
				% get points
				points = this.samples;
				
				% scale by weights
				points = bsxfun(@times, points, this.config.input.getWeights());
			end
			
			% get metrics
			metrics = struct;
			metrics.intersite_distance = criterionMaximin(points, size(points,2));
			metrics.projected_distance = criterionNonCollapsing(points, size(points,2));
			
			% plot metrics
			if nargout == 0
				intersite_evolution = criterionMaximinEvolution(points, size(points,2));
				projected_evolution = criterionNonCollapsingEvolution(points, size(points,2));
				disp(sprintf('Intersite (maximin) distance: %d', metrics.intersite_distance));
				disp(sprintf('Projected (noncollapsing) distance: %d', metrics.projected_distance));
				[AX,H1,H2] = plotyy(criterionMaximinEvolution(points), intersite_evolution, criterionMaximinEvolution(points), projected_evolution);
				set(get(AX(1),'Ylabel'),'String','Intersite distance') 
				set(get(AX(2),'Ylabel'),'String','Projected distance')
				xlabel('Number of samples');
				title('Sequential design');
			end
		end
		
		%> @brief Generate a new set of points.
		function [this, newPoints] = generatePoints(this, numNewPoints)
			global plotFigure;
			
			% no points specified - default to step size
			if isempty(numNewPoints)
				numNewPoints = this.stepSize;
			end
			
			% we require outputs?
			if this.requireOutputs
				if numNewPoints ~= this.stepSize || this.nOutputsAdded ~= size(this.samples,1)
					this.logger.warning(sprintf('This sample selector requires that you return the outputs for each of the points that were previously selected.'));
					this.logger.warning(sprintf('You can do this in the following way:'));
					this.logger.warning(sprintf('[seq, newPoints] = seq.generatePoints(1);'));
					this.logger.warning(sprintf('%% simulate newPoints here, get newOutputs'));
					this.logger.warning(sprintf('[seq] = seq.updatePoints(newPoints, newOutputs);'));
					this.logger.warning(sprintf('You must also provide outputs for points returned by the initial design.'));
					this.logger.warning(sprintf('This requirement also means that the number of points requested must be identical to the step size (default 1), because the sample selector can only perform one iteration per generatePoints request.'));
					this.logger.severe('Aborting...');
				end
			end
			
			% generate points in batches of stepSize
			newPoints = zeros(0, this.config.input.getInputDimension());
			for i = 1 : floor(numNewPoints / this.stepSize)
				
				% generate the points
				state = this.makeState(this.stepSize);
				[this.generator, points] = this.generator.selectSamples(state);
				this.samples = [this.samples ; points];
				this.values = [this.values ; zeros(size(points,1), this.config.output.getOutputDimension())];
				newPoints = [newPoints ; points];
				
				% plot the total points
				if this.plotLive && size(this.samples,2) == 2
					if isempty(plotFigure)
						plotFigure = figure();
					else
						figure(plotFigure);
					end
					samples = this.getAllPoints();
					plot(samples(:,1), samples(:,2), 'or');
					hold on;
					for i = 1 : size(samples,1)
						plot([samples(i,1) samples(i,1)], [this.inputMinima(2) this.inputMaxima(2)], 'g');
						plot([this.inputMinima(1) this.inputMaxima(1)], [samples(i,2) samples(i,2)], 'b');
					end
					%hold off;
				end
			end
			
			logger = Logger.getLogger('SequentialDesign');
			if size(newPoints,1) == 1
				logger.info(sprintf('Selected %d new point (%d total)', size(newPoints,1), size(this.samples,1)));
			else
				logger.info(sprintf('Selected %d new points (%d total)', size(newPoints,1), size(this.samples,1)));
			end
			newPoints = this.transformToSimulatorSpace(newPoints);
		end
		
		%> @brief Generate a number of points up to the specified total.
		function [this, newPoints] = generateTotalPoints(this, numTotalPoints)
			if size(this.samples,1) > numTotalPoints
				this.logger.warning(sprintf('This design already contains %d points, which is more than the requested total of %d', size(this.samples,1), numTotalPoints));
			end
			numNewPoints = numTotalPoints - size(this.samples,1);
			[this, newPoints] = this.generatePoints(numNewPoints);
		end
		
		
		%> @brief Set the step size of the design.
		%> The step size defines how many points are selected by the
		%> algorithm at once. A larger step size can considerably increase
		%> the speed of the algorithm.
		function [this] = setStepSize(this, size)
			if this.config.input.getInputDimension() ~= 2
				this.logger.warning('This function only works for 2D designs.');
			end
			this.stepSize = size;
		end
		
		%> @brief Plot the generated design after generating each point.
		function [this] = setPlotLive(this, plotLive)
			this.plotLive = plotLive;
		end
		
		
		%> @brief Updates the newest set of samples to other sample values.
		%> This can be used to clip the points generated by the algorithm
		%> to those that you prefer for further processing. Optionally, you
		%> can also add the simulator values produced by evaluating these
		%> new points. These can then be used by algorithms that require the
		%> outputs as well.
		%> @param newPoints A matrix of the n most recently generated points. Replaces the last n points generated by the algorithm.
		%> @param newValues Optional paramter containing the simulator output for these new points.
		function [this] = updatePoints(this, newPoints, newValues)
			n = size(newPoints,1);
			logger = this.logger;
			
			% transform back to model space
			newPoints = this.transformToModelSpace(newPoints);
			
			% update the points
			if size(newPoints,2) ~= this.config.input.getInputDimension()
				logger.severe('newPoints does not have the same number of columns as there are inputs defined in the problem xml.');
			end
			this.samples((end-n+1):end,:) = newPoints;
			
			% update the values
			if exist('newValues', 'var')
				if n ~= size(newValues,1)
					logger.severe('newPoints and newValues must contain the same number of rows, one for each point.');
				end
				if size(newValues,2) ~= this.config.output.getOutputDimension()
					logger.severe('newValues does not have the same number of columns as there are outputs defined in the problem xml.');
				end
				this.values((end-n+1):end,:) = newValues;
			end
			
			% update number of points for which an output was provided
			this.nOutputsAdded = this.nOutputsAdded + size(newValues,1);
		end
		
		
		%> @brief Plot the design points (only for 1-3D).
		function [] = plot(this)
			samples = this.transformToSimulatorSpace(this.samples);
			if size(samples,2) > 3
				this.logger.info(sprintf('You can only plot the points for 1-3D, while your problem is %dD.', size(samples,2)));
			end
			if size(samples,2) == 1
				plot(samples, 0, 'ob', 'MarkerFaceColor','b');
				xlabel(this.config.input.getInputDescription(0).getName());
			elseif size(samples,2) == 2
				plot(samples(:,1), samples(:,2), 'ob', 'MarkerFaceColor','b');
				xlabel(this.config.input.getInputDescription(0).getName());
				ylabel(this.config.input.getInputDescription(1).getName());
			else
				plot3(samples(:,1), samples(:,2), samples(:,3), 'ob', 'MarkerFaceColor','b');
				xlabel(this.config.input.getInputDescription(0).getName());
				ylabel(this.config.input.getInputDescription(1).getName());
				zlabel(this.config.input.getInputDescription(2).getName());
				grid on;
				axis square;
			end
		end
		
		
		%> @brief Save all the points to file.
		function [] = save(this, fileName)
			logger = this.logger;

			fid = -1;

			try
				inputNames = '';
				for i = 0 : this.config.input.getInputDimension() - 1
					if i > 0; inputNames = [inputNames ',']; end;
					inputNames = [inputNames char(this.config.input.getInputDescription(i).getName())];
				end
				outputNames = '';
				for i = 0 : this.config.output.getOutputDimension() - 1
					if i > 1; outputNames = [outputNames ',']; end;
					outputNames = [outputNames char(this.config.output.getOutputDescription(i).getName())];
				end
				if isempty(outputNames)
					header = ['% [' inputNames ']' 10];
				else
					header = ['% [' inputNames '] -> [' outputNames ']' 10];
				end

				fid = fopen(fileName, 'w+');
				fwrite(fid, header);

				dataset = [this.transformToSimulatorSpace(this.samples) this.values];

				% save everything
				[m,n] = size(dataset);
				for i = 1 : m

					% print numbers
					for j = 1 : n
						fprintf(fid, '%e ', dataset(i,j));
					end

					fprintf(fid, '\r\n');
				end

				fclose(fid);

			catch err
				msg = sprintf('Problem when saving the current samples list to %s: %s', fileName, err.message);
				logger.severe(msg);
				printStackTrace(err.stack,s.logger, Level.SEVERE);

				% Make sure we always close the file
				try
				  fclose(fid);
				catch err
				  % ignore
				end
			end

			
		end
		
	end
	
	methods(Access = private)
		function [this] = makeConfig(this, problem, methodFile)
			
			% is the problem a struct?
			if isstruct(problem)
				prob = problem;
			
			% it's an xml file, process it
			else
				
				% first get the problem file and process that data
				problemXML = xmlread(problem);
				root = problemXML.getDocumentElement();
				prob = NodeConfig(root);
			end

			% create base config
			config = struct;
			config.input = InputConfig(prob);
			config.output = OutputConfig(prob);

			% get the simulator-to-model space transformation
			this.inputMinima = config.input.getMinima();
			this.inputMaxima = config.input.getMaxima();
			
			% create the constraint manager
			if isstruct(problem)
				inputConstraints = ConstraintManager(problem.inputs.nInputs);
			else
				inputConstraints = ConstraintManager(config, @(points)(bsxfun(@plus, bsxfun(@times, (points + 1) ./ 2, (this.inputMaxima - this.inputMinima)), this.inputMinima)));
			end
			Singleton('ConstraintManager', inputConstraints);

			% try to parse the config file
			doc = xmlread(methodFile);
			root = doc.getDocumentElement();
			config.self = NodeConfig(root);

			% store method
			this.config = config;
			
			% logger
			logger = Logger.getLogger('SequentialDesign');
			
			% create the sample selector
			sampleSelector = config.self.selectSingleNode('SampleSelector');
			if isempty(sampleSelector)
				logger.severe(sprintf('No SampleSelector tag defined in the method xml file %s!', methodFile));
			else
				
				% construct the sample selector
				this.generator = instantiate(sampleSelector, config);
				
				% check if the sample selector needs outputs
				tmp = NodeConfig(sampleSelector);
				this.requireOutputs = tmp.getBooleanAttrValue('requireOutputs', 'false');
			end
			initialDesign = config.self.selectSingleNode('InitialDesign');
			if isempty(initialDesign)
				this.initialDesign = [-ones(1, config.input.getInputDimension()) ; ones(1, config.input.getInputDimension())];
			else
				initialDesignGenerator = instantiate(initialDesign, config);
				this.initialDesign = initialDesignGenerator.generate();
			end

		end
		
		function [state] = makeState(this, numNewSamples)
			state = struct;

			state.samples = this.samples;
			state.values = this.values;

			state.samplesFailed = [];
			state.valuesFailed = [];
			state.lastModels = [];

			state.numNewSamples = numNewSamples;

			state.triangulation = Triangulation(state.samples);
		end
		
		function [points] = transformToSimulatorSpace(this, points)
			points = bsxfun(@plus, bsxfun(@times, (points + 1) ./ 2, (this.inputMaxima - this.inputMinima)), this.inputMinima);
		end
		
		function [points] = transformToModelSpace(this, points)
			points = bsxfun(@rdivide, bsxfun(@minus, points, this.inputMinima), (this.inputMaxima - this.inputMinima)) .* 2 - 1;
		end
	end
	
end

